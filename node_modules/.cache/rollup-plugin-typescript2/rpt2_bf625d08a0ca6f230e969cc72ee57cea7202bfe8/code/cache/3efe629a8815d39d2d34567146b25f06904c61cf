{"code":"import { Orientation } from \"./_types\";\r\nexport function queryp(query) {\r\n    return Object.entries(query).map(([key, val]) => `${key}=${val}`).join(\"&\");\r\n}\r\nasync function format_tumblr_post(post) {\r\n    let imgs = { default: '', hires: '', album: [] };\r\n    let vids = {};\r\n    let dims = { width: 0, height: 0 };\r\n    let is_video = false;\r\n    let is_image = false;\r\n    let url = post.post_url;\r\n    if (post.type === \"photo\" && post.photos && post.photos.length > 0) {\r\n        is_image = true;\r\n        const originalPhoto = post.photos[0].original_size;\r\n        imgs = {\r\n            default: originalPhoto.url,\r\n            hires: originalPhoto.url,\r\n            album: post.photos.map(photo => ({\r\n                default: photo.original_size.url,\r\n                hires: photo.original_size.url,\r\n                is_image: true,\r\n                is_video: false,\r\n                preview: {\r\n                    vid: {},\r\n                    img: {\r\n                        hires: photo.original_size.url,\r\n                        default: photo.original_size.url,\r\n                        album: [],\r\n                    },\r\n                },\r\n            })),\r\n        };\r\n        dims = { width: originalPhoto.width, height: originalPhoto.height };\r\n        url = originalPhoto.url;\r\n    }\r\n    else if (post.type === \"video\" && post.video_url) {\r\n        is_video = true;\r\n        vids = {\r\n            mp4: post.video_url,\r\n            lores: post.video_url, // Assuming lores can be the same for now\r\n        };\r\n        // Try to get dimensions from player if available\r\n        if (post.player && post.player.length > 0) {\r\n            // This is a simplification, as embed code might not directly give dims\r\n            // For now, we'll just use a placeholder or try to parse from embed_code if possible\r\n            // For a real implementation, you'd need to parse the embed_code or fetch video metadata\r\n            dims = { width: post.player[0].width, height: post.player[0].width * (9 / 16) }; // Assuming 16:9 aspect ratio\r\n        }\r\n        url = post.video_url;\r\n    }\r\n    let orientation = Orientation.Normal;\r\n    if (dims.width && dims.height) {\r\n        if ((dims.width / dims.height) <= 0.7) {\r\n            orientation = Orientation.Portrait;\r\n        }\r\n        else if ((dims.width / dims.height) >= 1.7) {\r\n            orientation = Orientation.Landscape;\r\n        }\r\n    }\r\n    return {\r\n        id: String(post.id),\r\n        author: post.blog_name,\r\n        authorp: `u/${post.blog_name}`,\r\n        title: post.title || post.summary || \"(no title)\",\r\n        thumbnail: is_image ? imgs.default : undefined,\r\n        subreddit: post.blog_name,\r\n        subredditp: `t/${post.blog_name}`,\r\n        permalink: post.post_url,\r\n        over18: false,\r\n        is_video: is_video,\r\n        is_image: is_image,\r\n        is_album: is_image && imgs.album && imgs.album.length > 1,\r\n        favorite: false,\r\n        url: url,\r\n        dims: dims,\r\n        orientation: orientation,\r\n        preview: { vid: vids, img: imgs },\r\n    };\r\n}\r\nexport async function get_tumblr_posts(url) {\r\n    try {\r\n        const res = await fetch(url);\r\n        console.log(\"[get_tumblr_posts] Raw Response Object:\", res);\r\n        const data = await res.json();\r\n        console.log(\"[get_tumblr_posts] Raw API Data:\", data);\r\n        console.log(\"[get_tumblr_posts] Raw API Data.response:\", data.response);\r\n        if (data.meta.status !== 200) {\r\n            console.error(\"[get_tumblr_posts]: API error\", data.meta.msg);\r\n            return {\r\n                posts: [],\r\n                after: null,\r\n                res: { ok: false, res: data.meta.msg },\r\n            };\r\n        }\r\n        const rawPosts = data.response.posts;\r\n        console.log(\"[get_tumblr_posts] Raw Posts Array:\", rawPosts);\r\n        rawPosts.forEach(post => console.log(\"[get_tumblr_posts] Post Type:\", post.type));\r\n        const formattedPosts = await Promise.all(rawPosts.map(post => format_tumblr_post(post)));\r\n        // Filter for only image and video posts for now, similar to redditpx\r\n        const filteredPosts = formattedPosts.filter((post) => post.is_image || post.is_video);\r\n        // Tumblr API uses 'offset' for pagination, not 'after'.\r\n        // We'll return the next offset based on the number of posts returned.\r\n        // This assumes the API returns a 'limit' number of posts per request.\r\n        const nextOffset = data.response.posts.length > 0 ? (parseInt(url.match(/offset=(\\d+)/)?.[1] || \"0\") + data.response.posts.length) : null;\r\n        return {\r\n            posts: filteredPosts,\r\n            after: nextOffset,\r\n            res: { ok: true, res },\r\n        };\r\n    }\r\n    catch (error) {\r\n        console.error(\"[get_tumblr_posts]: error\", error);\r\n        return {\r\n            posts: [],\r\n            after: null,\r\n            res: { ok: false, res: error },\r\n        };\r\n    }\r\n}\r\n","references":["/Users/chrislapointe/Scripts/Gemini/tumblrpx/src/_types.ts"]}
