{"code":"import { Orientation } from \"./_types\";\r\nexport function queryp(query) {\r\n    return Object.entries(query).map(([key, val]) => `${key}=${val}`).join(\"&\");\r\n}\r\nasync function format_tumblr_post(post) {\r\n    let imgs = { default: '', hires: '', album: [] };\r\n    let vids = {};\r\n    let dims = { width: 0, height: 0 };\r\n    let is_video = false;\r\n    let is_image = false;\r\n    let url = post.post_url;\r\n    if (post.type === \"photo\" && post.photos && post.photos.length > 0) {\r\n        is_image = true;\r\n        const best_photos = post.photos.map(photo => {\r\n            let all_sizes = [...photo.alt_sizes];\r\n            if (photo.original_size) {\r\n                all_sizes.push(photo.original_size);\r\n            }\r\n            return all_sizes.reduce((prev, current) => (prev.width > current.width) ? prev : current);\r\n        });\r\n        const best_photo = best_photos[0];\r\n        imgs = {\r\n            default: best_photo.url,\r\n            hires: best_photo.url,\r\n            album: best_photos.map(p => ({\r\n                default: p.url,\r\n                hires: p.url,\r\n                is_image: true,\r\n                is_video: false,\r\n                preview: {\r\n                    vid: {},\r\n                    img: {\r\n                        hires: p.url,\r\n                        default: p.url,\r\n                        album: [],\r\n                    },\r\n                },\r\n            })),\r\n        };\r\n        dims = { width: best_photo.width, height: best_photo.height };\r\n        url = best_photo.url;\r\n    }\r\n    else if (post.type === \"video\" && post.video_url) {\r\n        is_video = true;\r\n        vids = {\r\n            mp4: post.video_url,\r\n            lores: post.video_url, // Assuming lores can be the same for now\r\n        };\r\n        // Try to get dimensions from player if available\r\n        if (post.player && post.player.length > 0) {\r\n            // This is a simplification, as embed code might not directly give dims\r\n            // For now, we'll just use a placeholder or try to parse from embed_code if possible\r\n            // For a real implementation, you'd need to parse the embed_code or fetch video metadata\r\n            dims = { width: post.player[0].width, height: post.player[0].width * (9 / 16) }; // Assuming 16:9 aspect ratio\r\n        }\r\n        url = post.video_url;\r\n    }\r\n    else if (post.type === \"text\" && post.body) {\r\n        const imgRegex = /<img[^>]+src=\"([^\">]+)\"/g;\r\n        const foundImages = [];\r\n        let match;\r\n        while ((match = imgRegex.exec(post.body)) !== null) {\r\n            foundImages.push(match[1]);\r\n        }\r\n        if (foundImages.length > 0) {\r\n            is_image = true;\r\n            const getHiResUrl = (url) => url.replace(/_\\d{3,}\\.(jpg|png|gif|webp)$/, '_1280.$1').replace(/\\/s\\d+x\\d+\\//, '/');\r\n            const hiresImages = foundImages.map(getHiResUrl);\r\n            imgs = {\r\n                default: foundImages[0],\r\n                hires: hiresImages[0],\r\n                album: foundImages.map((imgUrl, i) => ({\r\n                    default: imgUrl,\r\n                    hires: hiresImages[i],\r\n                    is_image: true,\r\n                    is_video: false,\r\n                    preview: {\r\n                        vid: {},\r\n                        img: {\r\n                            hires: hiresImages[i],\r\n                            default: imgUrl,\r\n                            album: [],\r\n                        },\r\n                    },\r\n                })),\r\n            };\r\n            // For now, we can't easily get dimensions from the body.\r\n            dims = { width: 0, height: 0 };\r\n            url = foundImages[0];\r\n        }\r\n        else {\r\n            console.log(`[format_tumblr_post] Text post with no images. ID: ${post.id}`);\r\n        }\r\n    }\r\n    else {\r\n        // Log posts that are not identified as image or video\r\n        console.log(`[format_tumblr_post] Post not identified as image/video. Type: ${post.type}, Post:`, post);\r\n    }\r\n    let orientation = Orientation.Normal;\r\n    if (dims.width && dims.height) {\r\n        if ((dims.width / dims.height) <= 0.7) {\r\n            orientation = Orientation.Portrait;\r\n        }\r\n        else if ((dims.width / dims.height) >= 1.7) {\r\n            orientation = Orientation.Landscape;\r\n        }\r\n    }\r\n    const nsfw_tags = [\"nsfw\", \"adult\", \"mature\", \"18+\", \"explicit\"];\r\n    const is_nsfw = post.tags.some(tag => nsfw_tags.includes(tag.toLowerCase()));\r\n    return {\r\n        id: String(post.id),\r\n        author: post.blog_name,\r\n        authorp: `u/${post.blog_name}`,\r\n        title: post.title || post.summary || \"(no title)\",\r\n        thumbnail: is_image ? imgs.default : undefined,\r\n        subreddit: post.blog_name,\r\n        subredditp: `t/${post.blog_name}`,\r\n        permalink: post.post_url,\r\n        over18: is_nsfw,\r\n        is_video: is_video,\r\n        is_image: is_image,\r\n        is_album: is_image && imgs.album && imgs.album.length > 1,\r\n        favorite: false,\r\n        url: url,\r\n        dims: dims,\r\n        orientation: orientation,\r\n        preview: { vid: vids, img: imgs },\r\n    };\r\n}\r\nexport async function get_tumblr_posts(url) {\r\n    try {\r\n        console.log(\"[get_tumblr_posts] API URL:\", url);\r\n        const res = await fetch(url);\r\n        console.log(\"[get_tumblr_posts] Raw Response Object:\", res);\r\n        const data = await res.json();\r\n        console.log(\"[get_tumblr_posts] Raw API Data:\", data);\r\n        console.log(\"[get_tumblr_posts] Raw API Data.response:\", data.response);\r\n        if (data.meta.status !== 200) {\r\n            console.error(\"[get_tumblr_posts]: API error\", data.meta.msg);\r\n            return {\r\n                posts: [],\r\n                after: null,\r\n                res: { ok: false, res: data.meta.msg },\r\n            };\r\n        }\r\n        const rawPosts = data.response.posts || data.response;\r\n        console.log(\"[get_tumblr_posts] Raw Posts Array (before filtering):\", rawPosts);\r\n        rawPosts.forEach(post => console.log(`[get_tumblr_posts] Post Type: ${post.type}, ID: ${post.id}`));\r\n        const formattedPosts = await Promise.all(rawPosts.map(post => format_tumblr_post(post)));\r\n        // Filter for only image and video posts for now, similar to redditpx\r\n        const filteredPosts = formattedPosts.filter((post) => post.is_image || post.is_video);\r\n        let after_value;\r\n        if (url.includes('/tagged')) {\r\n            if (rawPosts.length > 0) {\r\n                after_value = rawPosts[rawPosts.length - 1].timestamp;\r\n            }\r\n            else {\r\n                after_value = null;\r\n            }\r\n        }\r\n        else {\r\n            after_value = rawPosts.length > 0 ? (parseInt(url.match(/offset=(\\d+)/)?.[1] || \"0\") + rawPosts.length) : null;\r\n        }\r\n        return {\r\n            posts: filteredPosts,\r\n            after: after_value,\r\n            res: { ok: true, res },\r\n        };\r\n    }\r\n    catch (error) {\r\n        console.error(\"[get_tumblr_posts]: error\", error);\r\n        return {\r\n            posts: [],\r\n            after: null,\r\n            res: { ok: false, res: error },\r\n        };\r\n    }\r\n}\r\n","references":["/Users/chrislapointe/Scripts/Gemini/tumblrpx/src/_types.ts"]}
